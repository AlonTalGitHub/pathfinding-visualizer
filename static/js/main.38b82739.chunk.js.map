{"version":3,"sources":["components/Node/Node.js","components/Toolbar/Toolbar.js","components/NodesIndex/NodesIndex.js","algorithms/dijkstra.js","components/PathfindingVisualizer/PathfindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","row","col","isFinish","isStart","isWall","isVisited","isShortestPath","onMouseDown","onMouseEnter","onMouseUp","startClassName","finishClassName","wallClassName","visitedClassName","shortestPathClassName","id","className","Toolbar","visualizeDijkstra","clearBoard","clearPath","createRandomMaze","changeButtonClass","i","document","getElementById","classList","add","remove","disabled","onClick","NodesIndex","dijkstra","grid","startNode","finishNode","unvisitedNodes","nodes","node","push","getAllNodes","visitedNodesInOrder","distance","buildMinHeap","length","visitedNode","extractMin","Infinity","updateAdjacentNodes","pop","previousNode","size","Math","floor","minHeapify","smallest","left","right","temp","minNode","PathfindingVisualizer","useState","setGrid","mouseIsPressed","setMouseIsPressed","useEffect","resetGrid","window","mobileCheck","a","check","navigator","userAgent","vendor","opera","test","substr","getInitialGrid","rows","columns","newGrid","currentRow","createNode","newNode","console","log","handleMouseUp","animateShortestPath","nodesInShortestPathOrder","setTimeout","startNodeClass","finishNodeClass","arrowNodeClass","getArrowDirectionClass","getNewGridWithWallToggled","slice","animateDijkstra","currentNode","unshift","getNodesInShortestPathOrder","random","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","App","Boolean","location","hostname","match","ReactDOM","render","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.38b82739.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\n\nimport './Node.css';\n\n\nexport default function Node(props) {\n\n    // const [node, setNode] = useState({});\n\n    // const loadNode = () => {\n    //     console.log(node)\n    // }\n    // useEffect(() => {\n    //     loadNode()\n    // }, [node]);\n\n    const {\n        row,\n        col,\n        isFinish,\n        isStart,\n        isWall,\n        isVisited,\n        isShortestPath,\n        onMouseDown,\n        onMouseEnter,\n        onMouseUp,\n    } = props;\n    const startClassName = isStart ? 'node-start' : '';\n    const finishClassName = isFinish ? 'node-finish' : '';\n    const wallClassName = isWall ? 'node-wall' : '';\n    const visitedClassName = isVisited ? 'node-visited' : '';\n    const shortestPathClassName = isShortestPath ? 'node-shortest-path' : '';\n\n    return (\n        <td\n            id={`node-${row}-${col}`}\n            className={`node ${startClassName} ${finishClassName} ${wallClassName} ${visitedClassName} ${shortestPathClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseUp={() => onMouseUp()}\n        ></td>\n    );\n}","import React, { useState, useEffect } from 'react';\n\nimport './Toolbar.css';\n\n\nexport default function Toolbar(props) {\n\n    const { visualizeDijkstra, clearBoard, clearPath, createRandomMaze } = props;\n    \n    const visualizeAlgorithm = () => { \n        changeButtonClass();\n        visualizeDijkstra(); \n    };\n\n    const changeButtonClass = () => {\n        for (let i = 0; i < 4; i++) {\n            if (i === 0) {\n                document.getElementById('btn-0').classList.add('visualize-btn-running');\n                document.getElementById('btn-0').classList.remove('visualize-btn');\n            } else {\n                document.getElementById(`btn-${i}`).classList.add('toolbar-btn-running');\n                document.getElementById(`btn-${i}`).classList.remove('toolbar-btn');\n            }\n            document.getElementById(`btn-${i}`).disabled = true;\n        }\n    };\n\n    return (\n        <div className=\"toolbar-container\">\n            <div className=\"main-logo\">Route Finder</div>\n            <div className=\"toolbar-manu\">\n                <button id=\"btn-0\" className=\"visualize-btn\" onClick={visualizeAlgorithm}>Visualize Dijkstra's!</button>\n                <button id=\"btn-1\" className=\"toolbar-btn\" onClick={clearBoard}>Clear Board</button>\n                <button id=\"btn-2\" className=\"toolbar-btn\" onClick={clearPath}>Clear Path</button>\n                <button id=\"btn-3\" className=\"toolbar-btn\" onClick={createRandomMaze}>Create Random Maze</button>\n            </div>\n        </div>\n    );\n}\n\n\n\n\n\n\n\n\n\n\n\n","import React from 'react';\nimport Node from '../Node/Node.js';\n\nimport '../Node/Node.css';\nimport './NodesIndex.css';\n\n\nexport default function NodesIndex(props) {\n\n    return (\n        <div id='mainText'>\n        <ul>\n          <li className=\"icon-text\">\n          <div className=\"node node-start icon\"></div> Start Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-finish icon\"></div> Target Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node icon\"></div> Unvisited Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-visited icon\"></div> Visited Nodes</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-shortest-path icon\"></div> Shortest-path Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-wall icon\"></div> Wall Node</li>\n        </ul>\n      </div>\n    );\n}\n\n\n","\nexport default function dijkstra(grid, startNode, finishNode) {\n\n    const unvisitedNodes = getAllNodes(grid);\n\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    buildMinHeap(unvisitedNodes);\n\n    while (unvisitedNodes.length) {\n        const visitedNode = extractMin(unvisitedNodes);\n        if (!visitedNode) return visitedNodesInOrder;\n\n        if (visitedNode.isWall) continue;\n        \n        if (visitedNode.distance === Infinity) return visitedNodesInOrder;\n\n        visitedNode.isVisited = true;\n        visitedNodesInOrder.push(visitedNode);\n\n        if (visitedNode === finishNode) return visitedNodesInOrder;\n        updateAdjacentNodes(unvisitedNodes, visitedNode, visitedNodesInOrder);\n\n    }\n    return visitedNodesInOrder;\n}\n\nfunction updateAdjacentNodes(unvisitedNodes, visitedNode, visitedNodesInOrder) {\n    if (unvisitedNodes.length <= 1) {\n        visitedNodesInOrder.push(unvisitedNodes.pop());\n        return;\n    }\n    let adjacentCount = 0;\n    \n    for (const node of unvisitedNodes) {\n        if (node.isWall) continue;\n        if ((((node.row === visitedNode.row) && (node.col === visitedNode.col + 1 || node.col === visitedNode.col - 1)) ||\n        ((node.col === visitedNode.col) && (node.row === visitedNode.row + 1 || node.row === visitedNode.row - 1)))) {\n            if (node.distance > visitedNode.distance + 1) {\n                node.distance = visitedNode.distance + 1;\n                buildMinHeap(unvisitedNodes);\n                node.previousNode = visitedNode;\n                adjacentCount++;\n            }\n        }\n    }\n    \n    if (adjacentCount === 0) { }\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction createTestGrid() {\n    const grid = [];\n    for (let row = 0; row < 20; row++) {\n        grid[row] = [];\n        for (let col = 0; col < 50; col++) {\n            if (row === 10 && col === 15) {\n                grid[row].push({ row, col, isStart: true, isFinish: false, isWall: false, isVisited: false, distance: Infinity })\n            } else if (row === 10 && col === 35) {\n                grid[row].push({ row, col, isStart: false, isFinish: true, isWall: false, isVisited: false, distance: Infinity })\n            } else {\n                let isWall = false;\n                if (col === 28 && row !== getRandomIntFromInterval(0, 10) && row !== getRandomIntFromInterval(11, 19)) isWall = true;\n                grid[row].push({ row, col, isStart: false, isFinish: false, isWall, isVisited: false, distance: Infinity })\n            }\n            \n        }\n    }\n    return grid;\n}\n\nfunction getStartNode(grid) {\n    for (const row of grid) {\n        for (const node of row) {\n            if (node.isStart === true) return node;\n        }\n    }\n}\n\nfunction getFinishNode(grid) {\n    for (const row of grid) {\n        for (const node of row) {\n            if (node.isFinish === true) return node;\n        }\n    }\n}\n\n\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n\nfunction getRandomIntFromInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is exclusive and the minimum is inclusive\n}\n\n/*************** Heap Helper functions ***************/\n\nfunction buildMinHeap(nodes) {\n    const size = nodes.length;\n    \n    for (let i = Math.floor(size / 2) - 1; i >= 0; i--) {\n        minHeapify(nodes, size, i)\n    }\n    \n    return nodes;\n}\n\nfunction minHeapify(nodes, size, i) {\n    let smallest = i;\n    let left = i * 2 + 1;\n    let right = left + 1;\n\n    if (right < size && nodes[right].distance < nodes[smallest].distance) {\n        smallest = right\n    }\n    \n    if (left < size && nodes[left].distance < nodes[smallest].distance) {\n        smallest = left;\n    }\n    \n    if (smallest !== i) {\n        const temp = nodes[i];\n        nodes[i] = nodes[smallest];\n        nodes[smallest] = temp;\n        minHeapify(nodes, size, smallest);\n    }\n    return nodes\n    \n}\n\nfunction extractMin(nodes) {\n    const minNode = nodes[0];\n    nodes[0] = nodes.pop()\n    let size = nodes.length - 1;\n    minHeapify(nodes, size, 0);\n    \n    return minNode;\n}\n\n","import React, { useState, useEffect } from 'react';\nimport Node from '../Node/Node.js';\nimport Toolbar from '../Toolbar/Toolbar.js';\nimport NodesIndex from '../NodesIndex/NodesIndex.js';\n\nimport dijkstra, { getNodesInShortestPathOrder } from '../../algorithms/dijkstra'\n\nimport './PathfindingVisualizer.css';\n\nconst WEB_SCREEN_ROWS = 25;\nconst WEB_SCREEN_COLUMNS = 60;\nconst MOBILE_SCREEN_ROWS = 11;\nconst MOBILE_SCREEN_COLUMNS = 20;\n\nconst START_NODE_ROW = 11;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 11;\nconst FINISH_NODE_COL = 50;\n\nconst MOBILE_START_NODE_ROW = 1;\nconst MOBILE_START_NODE_COL = 1;\nconst MOBILE_FINISH_NODE_ROW = 9;\nconst MOBILE_FINISH_NODE_COL = 18;\n\nexport default function PathfindingVisualizer(props) {\n    \n    const [grid, setGrid] = useState([]);\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\n    \n    useEffect(() => {\n        resetGrid();\n    }, []);\n    \n    window.mobileCheck = function() {\n        let check = false;\n        (function(a) {\n            if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) check = true;\n        })(navigator.userAgent||navigator.vendor||window.opera);\n        return check;\n    };\n    \n    const resetGrid = () => {\n        const grid = getInitialGrid();\n        setGrid(grid);\n    }\n    \n    const getInitialGrid = () => {\n        const newGrid = [];\n        let rows\n        let columns\n        if (window.mobileCheck()) {\n            rows = MOBILE_SCREEN_ROWS\n            columns = MOBILE_SCREEN_COLUMNS\n        } else {\n            rows = WEB_SCREEN_ROWS\n            columns = WEB_SCREEN_COLUMNS\n        }\n        for (let row = 0; row < rows; row++) {\n            const currentRow = [];\n            for (let col = 0; col < columns; col++) {\n                currentRow.push(createNode(row, col));\n            }\n            newGrid.push(currentRow);\n        }\n        return newGrid;\n    };\n    \n    const createRandomMaze = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const newNode = createNode(row, col);\n                if (!newNode.isStart && !newNode.isFinish) {\n                    document.getElementById(`node-${row}-${col}`).className = `node`;\n                    newNode.isWall = Math.random() >= 0.7;\n                    if (newNode.isWall) {\n                        document.getElementById(`node-${row}-${col}`).className = `node node-wall`;\n                    }\n                }\n                if (newNode.isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n                \n                currentRow.push(newNode)\n            }\n            newGrid.push(currentRow)\n        }\n        setGrid(newGrid);\n    }\n\n    const createNode = (row, col) => {\n        if (window.mobileCheck()) {\n            return {\n                row,\n                col,\n                isStart: row === MOBILE_START_NODE_ROW && col === MOBILE_START_NODE_COL,\n                isFinish: row === MOBILE_FINISH_NODE_ROW && col === MOBILE_FINISH_NODE_COL,\n                distance: Infinity,\n                isVisited: false,\n                isWall: false,\n                isShortestPath: false,\n                previousNode: null,\n            }\n        } else {\n            return {\n                row,\n                col,\n                isStart: row === START_NODE_ROW && col === START_NODE_COL,\n                isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n                distance: Infinity,\n                isVisited: false,\n                isWall: false,\n                isShortestPath: false,\n                previousNode: null,\n            };\n        }\n    };\n    \n    const clearBoard = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const newNode = createNode(row, col);\n                if (!newNode.isStart && !newNode.isFinish) {\n                    document.getElementById(`node-${row}-${col}`).className =\n                        `node`;\n                }\n                if (newNode.isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n                \n                currentRow.push(newNode)\n            }\n            newGrid.push(currentRow)\n        }\n        setGrid(newGrid)\n    }\n\n    const clearPath = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const node = grid[row][col]\n                let newNode = createNode(row, col);\n                newNode = { ...newNode, \n                    isStart: node.isStart, \n                    isFinish: node.isFinish, \n                    isWall: node.isWall, \n                }\n                if (newNode.isStart) newNode.distance = 0;\n                currentRow.push(newNode);\n                document.getElementById(`node-${row}-${col}`).classList.remove('node-visited');\n                document.getElementById(`node-${row}-${col}`).classList.remove('node-shortest-path');\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish'; \n\n            }\n            newGrid.push(currentRow)\n        }\n        console.log(newGrid);\n        setGrid(newGrid);\n    }\n\n    const changeButtonClass = () => {\n        for (let i = 0; i < 4; i++) {\n            if (i === 0) {\n                document.getElementById('btn-0').classList.add('visualize-btn');\n                document.getElementById('btn-0').classList.remove('visualize-btn-running');\n            } else {\n                document.getElementById(`btn-${i}`).classList.add('toolbar-btn');\n                document.getElementById(`btn-${i}`).classList.remove('toolbar-btn-running');\n            }\n            document.getElementById(`btn-${i}`).disabled = false;\n        }\n    };\n\n    const handleMouseDown = (row, col) => { \n        const newGrid = getNewGridWithWallToggled(grid, row, col);\n        setGrid(newGrid);\n        setMouseIsPressed(true);\n    }\n\n    const handleMouseEnter = (row, col) => {\n        if (!mouseIsPressed) return;\n        const newGrid = getNewGridWithWallToggled(grid, row, col);\n        setGrid(newGrid);\n    }\n\n    const handleMouseUp = () => {\n        setMouseIsPressed(false);\n    }\n\n\n    const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length - 1) {\n                setTimeout(() => {\n                    animateShortestPath(nodesInShortestPathOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const startNodeClass = node.isStart ? 'node-start' : '';\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    `node node-visited ${startNodeClass}`;\n            }, 10 * i);\n        }\n    };\n\n    const animateShortestPath = (nodesInShortestPathOrder) => {\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n            setTimeout(() => {\n                const node = nodesInShortestPathOrder[i];\n                node.isShortestPath = true;\n                const startNodeClass = node.isStart ? 'node-start' : '';\n                const finishNodeClass = node.isFinish ? 'node-finish' : '';\n                const arrowNodeClass = getArrowDirectionClass(node);\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    `node node-shortest-path ${startNodeClass} ${finishNodeClass} ${arrowNodeClass}`;\n                setTimeout(() => {\n                    if (!node.isFinish) {\n                        document.getElementById(`node-${node.row}-${node.col}`).className =\n                            `node node-shortest-path ${startNodeClass} ${finishNodeClass}`;\n                    }\n                }, 2 * i);\n            }, 35 * i);\n            if (i === nodesInShortestPathOrder.length - 1) {\n                setTimeout(() => {\n                    changeButtonClass();\n                }, 50 * i);\n            }\n        }\n    };\n\n    const visualizeDijkstra = () => {\n        clearPath();\n        const startNode = window.mobileCheck() ? grid[MOBILE_START_NODE_ROW][MOBILE_START_NODE_COL] : grid[START_NODE_ROW][START_NODE_COL]\n        const finishNode = window.mobileCheck() ? grid[MOBILE_FINISH_NODE_ROW][MOBILE_FINISH_NODE_COL] : grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);        \n    };\n    \n    const getNewGridWithWallToggled = (grid, row, col) => {\n        if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n        const newGrid = grid.slice();\n        const node = newGrid[row][col];\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n        };\n        newGrid[row][col] = newNode;\n        return newGrid;\n    };\n    \n    const getArrowDirectionClass = (node) => {\n        const previousNode = node.previousNode;\n        if (!previousNode) return '';\n        const row = previousNode.row;\n        const col = previousNode.col;\n    \n        const arrowClassName = (row - 1 === node.row)\n            ? 'node-arrowup'\n            : (col - 1 === node.col)\n                ? 'node-arrowleft'\n                : (row + 1 === node.row)\n                    ? 'node-arrowdown'\n                    : 'node-arrowright';\n    \n        return arrowClassName;\n    }\n\n    return (\n        <div className=\"app-body\">\n            <Toolbar\n                visualizeDijkstra={visualizeDijkstra}\n                clearBoard={clearBoard} \n                clearPath={clearPath}\n                createRandomMaze={createRandomMaze}\n                ></Toolbar>\n            <NodesIndex></NodesIndex>\n            <div className=\"main-message\">Create a Maze and visualize the shortest path with Dijkstra's Algorithm!</div>\n            <table className=\"grid\">\n                <tbody>\n                    {grid.map((row, rowIdx) => {\n                        return <tr className=\"grid-row\" key={rowIdx}>\n                            {row.map((node, nodeIdx) => {\n                                const { row, col, isFinish, isStart, isWall, isVisited, isShortestPath } = node;\n                                return <Node\n                                    key={nodeIdx}\n                                    row={row}\n                                    col={col}\n                                    isFinish={isFinish}\n                                    isStart={isStart}\n                                    isWall={isWall}\n                                    isVisited={isVisited}\n                                    isShortestPath={isShortestPath}\n                                    mouseIsPressed={mouseIsPressed}\n                                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                                    onMouseUp={handleMouseUp}\n                                ></Node>\n                            })}\n                        </tr>\n                    })}\n                </tbody>\n            </table>\n        </div>\n    );\n}\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './components/PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}