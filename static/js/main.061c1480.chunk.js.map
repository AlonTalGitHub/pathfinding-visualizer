{"version":3,"sources":["components/Node/Node.js","components/Toolbar/Toolbar.js","components/NodesIndex/NodesIndex.js","algorithms/dijkstra.js","components/PathfindingVisualizer/PathfindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","row","col","isFinish","isStart","isWall","isVisited","isShortestPath","onMouseDown","onMouseEnter","onMouseUp","startClassName","finishClassName","wallClassName","visitedClassName","shortestPathClassName","id","className","Toolbar","visualizeDijkstra","clearBoard","clearPath","createRandomMaze","changeButtonClass","i","document","getElementById","classList","add","remove","disabled","onClick","NodesIndex","dijkstra","grid","startNode","finishNode","unvisitedNodes","nodes","node","push","getAllNodes","visitedNodesInOrder","distance","buildMinHeap","length","visitedNode","extractMin","Infinity","updateAdjacentNodes","pop","previousNode","size","Math","floor","minHeapify","smallest","left","right","temp","minNode","PathfindingVisualizer","useState","setGrid","mouseIsPressed","setMouseIsPressed","useEffect","resetGrid","console","log","getInitialGrid","newGrid","currentRow","createNode","newNode","handleMouseUp","animateShortestPath","nodesInShortestPathOrder","setTimeout","startNodeClass","finishNodeClass","arrowNodeClass","getArrowDirectionClass","getNewGridWithWallToggled","slice","animateDijkstra","currentNode","unshift","getNodesInShortestPathOrder","random","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.061c1480.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react';\n\nimport './Node.css';\n\n\nexport default function Node(props) {\n\n    // const [node, setNode] = useState({});\n\n    // const loadNode = () => {\n    //     console.log(node)\n    // }\n    // useEffect(() => {\n    //     loadNode()\n    // }, [node]);\n\n    const {\n        row,\n        col,\n        isFinish,\n        isStart,\n        isWall,\n        isVisited,\n        isShortestPath,\n        onMouseDown,\n        onMouseEnter,\n        onMouseUp,\n    } = props;\n    const startClassName = isStart ? 'node-start' : '';\n    const finishClassName = isFinish ? 'node-finish' : '';\n    const wallClassName = isWall ? 'node-wall' : '';\n    const visitedClassName = isVisited ? 'node-visited' : '';\n    const shortestPathClassName = isShortestPath ? 'node-shortest-path' : '';\n\n    return (\n        <td\n            id={`node-${row}-${col}`}\n            className={`node ${startClassName} ${finishClassName} ${wallClassName} ${visitedClassName} ${shortestPathClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseUp={() => onMouseUp()}\n        ></td>\n    );\n}","import React, { useState, useEffect } from 'react';\n\nimport './Toolbar.css';\n\n\nexport default function Toolbar(props) {\n\n    const { visualizeDijkstra, clearBoard, clearPath, createRandomMaze } = props;\n    \n    const visualizeAlgorithm = () => { \n        changeButtonClass();\n        visualizeDijkstra(); \n    };\n\n    const changeButtonClass = () => {\n        for (let i = 0; i < 4; i++) {\n            if (i === 0) {\n                document.getElementById('btn-0').classList.add('visualize-btn-running');\n                document.getElementById('btn-0').classList.remove('visualize-btn');\n            } else {\n                document.getElementById(`btn-${i}`).classList.add('toolbar-btn-running');\n                document.getElementById(`btn-${i}`).classList.remove('toolbar-btn');\n            }\n            document.getElementById(`btn-${i}`).disabled = true;\n        }\n    };\n\n    return (\n        <div className=\"toolbar-container\">\n            <div className=\"main-logo\">Pathfinding Visualizer</div>\n            <div className=\"toolbar-manu\">\n                <button id=\"btn-0\" className=\"visualize-btn\" onClick={visualizeAlgorithm}>Visualize Dijkstra's!</button>\n                <button id=\"btn-1\" className=\"toolbar-btn\" onClick={clearBoard}>Clear Board</button>\n                <button id=\"btn-2\" className=\"toolbar-btn\" onClick={clearPath}>Clear Path</button>\n                <button id=\"btn-3\" className=\"toolbar-btn\" onClick={createRandomMaze}>Create Random Maze</button>\n            </div>\n        </div>\n    );\n}\n\n\n\n\n\n\n\n\n\n\n\n","import React from 'react';\nimport Node from '../Node/Node.js';\n\nimport '../Node/Node.css';\nimport './NodesIndex.css';\n\n\nexport default function NodesIndex(props) {\n\n    return (\n        <div id='mainText'>\n        <ul>\n          <li className=\"icon-text\">\n          <div className=\"node node-start icon\"></div> Start Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-finish icon\"></div> Target Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node icon\"></div> Unvisited Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-visited icon\"></div> Visited Nodes</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-shortest-path icon\"></div> Shortest-path Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node node-wall icon\"></div> Wall Node</li>\n        </ul>\n      </div>\n    );\n}\n\n\n","\nexport default function dijkstra(grid, startNode, finishNode) {\n\n    const unvisitedNodes = getAllNodes(grid);\n\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    buildMinHeap(unvisitedNodes);\n\n    while (unvisitedNodes.length) {\n        const visitedNode = extractMin(unvisitedNodes);\n        if (!visitedNode) return visitedNodesInOrder;\n\n        if (visitedNode.isWall) continue;\n        \n        if (visitedNode.distance === Infinity) return visitedNodesInOrder;\n\n        visitedNode.isVisited = true;\n        visitedNodesInOrder.push(visitedNode);\n\n        if (visitedNode === finishNode) return visitedNodesInOrder;\n        updateAdjacentNodes(unvisitedNodes, visitedNode, visitedNodesInOrder);\n\n    }\n    return visitedNodesInOrder;\n}\n\nfunction updateAdjacentNodes(unvisitedNodes, visitedNode, visitedNodesInOrder) {\n    if (unvisitedNodes.length <= 1) {\n        visitedNodesInOrder.push(unvisitedNodes.pop());\n        return;\n    }\n    let adjacentCount = 0;\n    \n    for (const node of unvisitedNodes) {\n        if (node.isWall) continue;\n        if ((((node.row === visitedNode.row) && (node.col === visitedNode.col + 1 || node.col === visitedNode.col - 1)) ||\n        ((node.col === visitedNode.col) && (node.row === visitedNode.row + 1 || node.row === visitedNode.row - 1)))) {\n            if (node.distance > visitedNode.distance + 1) {\n                node.distance = visitedNode.distance + 1;\n                buildMinHeap(unvisitedNodes);\n                node.previousNode = visitedNode;\n                adjacentCount++;\n            }\n        }\n    }\n    \n    if (adjacentCount === 0) { }\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction createTestGrid() {\n    const grid = [];\n    for (let row = 0; row < 20; row++) {\n        grid[row] = [];\n        for (let col = 0; col < 50; col++) {\n            if (row === 10 && col === 15) {\n                grid[row].push({ row, col, isStart: true, isFinish: false, isWall: false, isVisited: false, distance: Infinity })\n            } else if (row === 10 && col === 35) {\n                grid[row].push({ row, col, isStart: false, isFinish: true, isWall: false, isVisited: false, distance: Infinity })\n            } else {\n                let isWall = false;\n                if (col === 28 && row !== getRandomIntFromInterval(0, 10) && row !== getRandomIntFromInterval(11, 19)) isWall = true;\n                grid[row].push({ row, col, isStart: false, isFinish: false, isWall, isVisited: false, distance: Infinity })\n            }\n            \n        }\n    }\n    return grid;\n}\n\nfunction getStartNode(grid) {\n    for (const row of grid) {\n        for (const node of row) {\n            if (node.isStart === true) return node;\n        }\n    }\n}\n\nfunction getFinishNode(grid) {\n    for (const row of grid) {\n        for (const node of row) {\n            if (node.isFinish === true) return node;\n        }\n    }\n}\n\n\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n\nfunction getRandomIntFromInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is exclusive and the minimum is inclusive\n}\n\n/*************** Heap Helper functions ***************/\n\nfunction buildMinHeap(nodes) {\n    const size = nodes.length;\n    \n    for (let i = Math.floor(size / 2) - 1; i >= 0; i--) {\n        minHeapify(nodes, size, i)\n    }\n    \n    return nodes;\n}\n\nfunction minHeapify(nodes, size, i) {\n    let smallest = i;\n    let left = i * 2 + 1;\n    let right = left + 1;\n\n    if (right < size && nodes[right].distance < nodes[smallest].distance) {\n        smallest = right\n    }\n    \n    if (left < size && nodes[left].distance < nodes[smallest].distance) {\n        smallest = left;\n    }\n    \n    if (smallest !== i) {\n        const temp = nodes[i];\n        nodes[i] = nodes[smallest];\n        nodes[smallest] = temp;\n        minHeapify(nodes, size, smallest);\n    }\n    return nodes\n    \n}\n\nfunction extractMin(nodes) {\n    const minNode = nodes[0];\n    nodes[0] = nodes.pop()\n    let size = nodes.length - 1;\n    minHeapify(nodes, size, 0);\n    \n    return minNode;\n}\n\n","import React, { useState, useEffect } from 'react';\nimport Node from '../Node/Node.js';\nimport Toolbar from '../Toolbar/Toolbar.js';\nimport NodesIndex from '../NodesIndex/NodesIndex.js';\n\nimport dijkstra, { getNodesInShortestPathOrder } from '../../algorithms/dijkstra'\n\nimport './PathfindingVisualizer.css';\n\nconst START_NODE_ROW = 11;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 11;\nconst FINISH_NODE_COL = 45;\n\nexport default function PathfindingVisualizer(props) {\n    \n    const [grid, setGrid] = useState([]);\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\n    \n    useEffect(() => {\n        resetGrid();\n    }, []);\n    \n    useEffect(() => {\n    }, [mouseIsPressed]);\n    \n    useEffect(() => {\n        console.log('rendering grid');\n    }, [grid]);\n    \n    const resetGrid = () => {\n        const grid = getInitialGrid();\n        setGrid(grid);\n    }\n    \n    const getInitialGrid = () => {\n        const newGrid = [];\n        for (let row = 0; row < 25; row++) {\n            const currentRow = [];\n            for (let col = 0; col < 60; col++) {\n                currentRow.push(createNode(row, col));\n            }\n            newGrid.push(currentRow);\n        }\n        return newGrid;\n    };\n    \n    const createRandomMaze = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const newNode = createNode(row, col);\n                if (!newNode.isStart && !newNode.isFinish) {\n                    document.getElementById(`node-${row}-${col}`).className = `node`;\n                    newNode.isWall = Math.random() >= 0.7;\n                    if (newNode.isWall) {\n                        document.getElementById(`node-${row}-${col}`).className = `node node-wall`;\n                    }\n                }\n                if (newNode.isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n                \n                currentRow.push(newNode)\n            }\n            newGrid.push(currentRow)\n        }\n        setGrid(newGrid);\n    }\n\n    const createNode = (row, col) => {\n        return {\n            row,\n            col,\n            isStart: row === START_NODE_ROW && col === START_NODE_COL,\n            isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n            distance: Infinity,\n            isVisited: false,\n            isWall: false,\n            isShortestPath: false,\n            previousNode: null,\n        };\n    };\n    \n    const clearBoard = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const newNode = createNode(row, col);\n                if (!newNode.isStart && !newNode.isFinish) {\n                    document.getElementById(`node-${row}-${col}`).className =\n                        `node`;\n                }\n                if (newNode.isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n                \n                currentRow.push(newNode)\n            }\n            newGrid.push(currentRow)\n        }\n        setGrid(newGrid)\n    }\n\n    const clearPath = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const node = grid[row][col]\n                let newNode = createNode(row, col);\n                newNode = { ...newNode, \n                    isStart: node.isStart, \n                    isFinish: node.isFinish, \n                    isWall: node.isWall, \n                }\n                if (newNode.isStart) newNode.distance = 0;\n                currentRow.push(newNode);\n                document.getElementById(`node-${row}-${col}`).classList.remove('node-visited');\n                document.getElementById(`node-${row}-${col}`).classList.remove('node-shortest-path');\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish'; \n\n            }\n            newGrid.push(currentRow)\n        }\n        console.log(newGrid);\n        setGrid(newGrid);\n    }\n\n    const changeButtonClass = () => {\n        for (let i = 0; i < 4; i++) {\n            if (i === 0) {\n                document.getElementById('btn-0').classList.add('visualize-btn');\n                document.getElementById('btn-0').classList.remove('visualize-btn-running');\n            } else {\n                document.getElementById(`btn-${i}`).classList.add('toolbar-btn');\n                document.getElementById(`btn-${i}`).classList.remove('toolbar-btn-running');\n            }\n            document.getElementById(`btn-${i}`).disabled = false;\n        }\n    };\n\n    const handleMouseDown = (row, col) => { \n        const newGrid = getNewGridWithWallToggled(grid, row, col);\n        setGrid(newGrid);\n        setMouseIsPressed(true);\n    }\n\n    const handleMouseEnter = (row, col) => {\n        if (!mouseIsPressed) return;\n        const newGrid = getNewGridWithWallToggled(grid, row, col);\n        setGrid(newGrid);\n    }\n\n    const handleMouseUp = () => {\n        setMouseIsPressed(false);\n    }\n\n\n    const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length - 1) {\n                setTimeout(() => {\n                    animateShortestPath(nodesInShortestPathOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const startNodeClass = node.isStart ? 'node-start' : '';\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    `node node-visited ${startNodeClass}`;\n            }, 10 * i);\n        }\n    };\n\n    const animateShortestPath = (nodesInShortestPathOrder) => {\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n            setTimeout(() => {\n                const node = nodesInShortestPathOrder[i];\n                node.isShortestPath = true;\n                const startNodeClass = node.isStart ? 'node-start' : '';\n                const finishNodeClass = node.isFinish ? 'node-finish' : '';\n                const arrowNodeClass = getArrowDirectionClass(node);\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    `node node-shortest-path ${startNodeClass} ${finishNodeClass} ${arrowNodeClass}`;\n                setTimeout(() => {\n                    if (!node.isFinish) {\n                        document.getElementById(`node-${node.row}-${node.col}`).className =\n                            `node node-shortest-path ${startNodeClass} ${finishNodeClass}`;\n                    }\n                }, 2 * i);\n            }, 35 * i);\n            if (i === nodesInShortestPathOrder.length - 1) {\n                setTimeout(() => {\n                    changeButtonClass();\n                }, 50 * i);\n            }\n        }\n    };\n\n    const visualizeDijkstra = () => {\n        clearPath();\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);        \n    };\n    \n    const getNewGridWithWallToggled = (grid, row, col) => {\n        if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n        const newGrid = grid.slice();\n        const node = newGrid[row][col];\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n        };\n        newGrid[row][col] = newNode;\n        return newGrid;\n    };\n    \n    const getArrowDirectionClass = (node) => {\n        const previousNode = node.previousNode;\n        if (!previousNode) return '';\n        const row = previousNode.row;\n        const col = previousNode.col;\n    \n        const arrowClassName = (row - 1 === node.row)\n            ? 'node-arrowup'\n            : (col - 1 === node.col)\n                ? 'node-arrowleft'\n                : (row + 1 === node.row)\n                    ? 'node-arrowdown'\n                    : 'node-arrowright';\n    \n        return arrowClassName;\n    }\n\n    return (\n        <div className=\"app-body\">\n            <Toolbar\n                visualizeDijkstra={visualizeDijkstra}\n                clearBoard={clearBoard} \n                clearPath={clearPath}\n                createRandomMaze={createRandomMaze}\n                ></Toolbar>\n            <NodesIndex></NodesIndex>\n            <div className=\"main-message\">Create a Maze and visualize the shortest path with Dijkstra's Algorithm!</div>\n            <table className=\"grid\">\n                <tbody>\n                    {grid.map((row, rowIdx) => {\n                        return <tr key={rowIdx}>\n                            {row.map((node, nodeIdx) => {\n                                const { row, col, isFinish, isStart, isWall, isVisited, isShortestPath } = node;\n                                return <Node\n                                    key={nodeIdx}\n                                    row={row}\n                                    col={col}\n                                    isFinish={isFinish}\n                                    isStart={isStart}\n                                    isWall={isWall}\n                                    isVisited={isVisited}\n                                    isShortestPath={isShortestPath}\n                                    mouseIsPressed={mouseIsPressed}\n                                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                                    onMouseUp={handleMouseUp}\n                                ></Node>\n                            })}\n                        </tr>\n                    })}\n                </tbody>\n            </table>\n        </div>\n    );\n}\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './components/PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}