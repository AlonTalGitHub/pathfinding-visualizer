{"version":3,"sources":["components/Node/Node.js","components/DropDownMenu.js","components/Header/Header.js","components/NodesIndex/NodesIndex.js","algorithms/dijkstra.js","components/PathfindingVisualizer/PathfindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","row","col","isFinish","isStart","isWall","isVisited","isShortestPath","onMouseDown","onMouseEnter","onMouseUp","startClassName","finishClassName","wallClassName","visitedClassName","shortestPathClassName","id","className","DropDownMenu","visualizeDijkstra","createRandomMaze","clearPath","clearBoard","React","useState","anchorEl","setAnchorEl","handleClose","aria-controls","aria-haspopup","onClick","event","currentTarget","Menu","keepMounted","open","Boolean","onClose","MenuItem","useStyles","makeStyles","theme","root","flexGrow","menuButton","marginRight","spacing","findRouteBtn","backgroundColor","title","Header","isRunning","classes","AppBar","position","Toolbar","IconButton","edge","color","aria-label","disabled","Typography","variant","Button","NodesIndex","dijkstra","grid","startNode","finishNode","unvisitedNodes","nodes","node","push","getAllNodes","visitedNodesInOrder","distance","buildMinHeap","length","visitedNode","extractMin","Infinity","updateAdjacentNodes","pop","previousNode","size","i","Math","floor","minHeapify","smallest","left","right","temp","minNode","PathfindingVisualizer","setGrid","mouseIsPressed","setMouseIsPressed","setIsRunning","useEffect","resetGrid","window","mobileCheck","a","check","navigator","userAgent","vendor","opera","test","substr","getInitialGrid","rows","columns","newGrid","currentRow","createNode","newNode","document","getElementById","classList","remove","console","log","toggleButton","prevState","handleMouseUp","animateShortestPath","nodesInShortestPathOrder","setTimeout","startNodeClass","finishNodeClass","arrowNodeClass","getArrowDirectionClass","getNewGridWithWallToggled","slice","animateDijkstra","currentNode","unshift","getNodesInShortestPathOrder","random","changeButtonClass","add","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","App","location","hostname","match","ReactDOM","render","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.d9a62392.chunk.js","sourcesContent":["import React from 'react';\n\nimport './Node.css';\n\n\nexport default function Node(props) {\n\n    const {\n        row,\n        col,\n        isFinish,\n        isStart,\n        isWall,\n        isVisited,\n        isShortestPath,\n        onMouseDown,\n        onMouseEnter,\n        onMouseUp,\n    } = props;\n    const startClassName = isStart ? 'node-start' : '';\n    const finishClassName = isFinish ? 'node-finish' : '';\n    const wallClassName = isWall ? 'node-wall' : '';\n    const visitedClassName = isVisited ? 'node-visited' : '';\n    const shortestPathClassName = isShortestPath ? 'node-shortest-path' : '';\n\n    return (\n        <td\n            id={`node-${row}-${col}`}\n            className={`node ${startClassName} ${finishClassName} ${wallClassName} ${visitedClassName} ${shortestPathClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseUp={() => onMouseUp()}\n        ></td>\n    );\n}","import React from 'react';\nimport Menu from '@material-ui/core/Menu';\nimport MenuIcon from \"@material-ui/icons/Menu\";\nimport MenuItem from '@material-ui/core/MenuItem';\n\nconst DropDownMenu = ({\n  visualizeDijkstra,\n  createRandomMaze,\n  clearPath,\n  clearBoard,\n}) => {\n\n  const [anchorEl, setAnchorEl] = React.useState(null);\n\n  const handleClick = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const handleCreateRandomMaze = () => {\n    createRandomMaze()\n    handleClose()\n  };\n\n  const handleClearPath = () => {\n    clearPath()\n    handleClose()\n  };\n\n  const handleClearBoard = () => {\n    clearBoard()\n    handleClose()\n  };\n\n  return (\n    <div>\n      <MenuIcon aria-controls=\"simple-menu\" aria-haspopup=\"true\" onClick={handleClick} />\n      <Menu\n        id=\"simple-menu\"\n        anchorEl={anchorEl}\n        keepMounted\n        open={Boolean(anchorEl)}\n        onClose={handleClose}\n      >\n        <MenuItem id=\"btn-1\" onClick={handleCreateRandomMaze}>Create Random Maze</MenuItem>\n        <MenuItem id=\"btn-2\" onClick={handleClearPath}>Clear Path</MenuItem>\n        <MenuItem id=\"btn-3\" onClick={handleClearBoard}>Clear Board</MenuItem>\n      </Menu>\n    </div>\n  );\n}\n\nexport default DropDownMenu;","import React from \"react\";\nimport AppBar from \"@material-ui/core/AppBar\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport Button from \"@material-ui/core/Button\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport { makeStyles } from \"@material-ui/core/styles\";\n\nimport DropDownMenu from \"../DropDownMenu\";\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    flexGrow: 1,\n  },\n  menuButton: {\n    marginRight: theme.spacing(2),\n  },\n  findRouteBtn: {\n    backgroundColor: \"#1abc9c\",\n    \"&:hover\": {\n        backgroundColor: \"#179B91\",\n    },\n  },\n  title: {\n    flexGrow: 1,\n  },\n}));\n\nconst Header = ({\n  visualizeDijkstra,\n  clearBoard,\n  clearPath,\n  createRandomMaze,\n  isRunning,\n}) => {\n  const classes = useStyles();\n\n  const visualizeAlgorithm = () => {\n    visualizeDijkstra();\n  };\n\n  return (\n      <div className={classes.root}>\n      <AppBar position=\"static\">\n        <Toolbar>\n          <IconButton\n            edge=\"start\"\n            className={classes.menuButton}\n            color=\"inherit\"\n            aria-label=\"menu\"\n            disabled={isRunning}\n          >\n            <DropDownMenu\n              clearBoard={clearBoard}\n              clearPath={clearPath}\n              createRandomMaze={createRandomMaze}\n            />\n          </IconButton>\n          <Typography variant=\"h6\" className={classes.title}>\n            Route Finder\n          </Typography>\n          <Button className={classes.findRouteBtn} id=\"btn-0\" color=\"inherit\" onClick={visualizeAlgorithm} disabled={isRunning}>\n            Find Route!\n          </Button>\n        </Toolbar>\n      </AppBar>\n    </div>\n  );\n};\n\nexport default Header;","import React from 'react';\n\nimport '../Node/Node.css';\nimport './NodesIndex.css';\n\n\nexport default function NodesIndex(props) {\n\n    return (\n      <div id='mainText'>\n        <ul className=\"icon-list\">\n          <li className=\"icon-text\">\n            <div className=\"node-icon node-start icon\"></div> Start Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node-icon node-finish icon\"></div> Target Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node-icon icon\"></div> Unvisited Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node-icon node-visited icon\"></div> Visited Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node-icon node-shortest-path icon\"></div> Route Node</li>\n          <li className=\"icon-text\">\n            <div className=\"node-icon node-wall icon\"></div> Wall Node</li>\n        </ul>\n      </div>\n    );\n}\n\n\n","\nexport default function dijkstra(grid, startNode, finishNode) {\n\n    const unvisitedNodes = getAllNodes(grid);\n\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    buildMinHeap(unvisitedNodes);\n\n    while (unvisitedNodes.length) {\n        const visitedNode = extractMin(unvisitedNodes);\n        if (!visitedNode) return visitedNodesInOrder;\n\n        if (visitedNode.isWall) continue;\n        \n        if (visitedNode.distance === Infinity) return visitedNodesInOrder;\n\n        visitedNode.isVisited = true;\n        visitedNodesInOrder.push(visitedNode);\n\n        if (visitedNode === finishNode) return visitedNodesInOrder;\n        updateAdjacentNodes(unvisitedNodes, visitedNode, visitedNodesInOrder);\n\n    }\n    return visitedNodesInOrder;\n}\n\nfunction updateAdjacentNodes(unvisitedNodes, visitedNode, visitedNodesInOrder) {\n    if (unvisitedNodes.length <= 1) {\n        visitedNodesInOrder.push(unvisitedNodes.pop());\n        return;\n    }\n    let adjacentCount = 0;\n    \n    for (const node of unvisitedNodes) {\n        if (node.isWall) continue;\n        if ((((node.row === visitedNode.row) && (node.col === visitedNode.col + 1 || node.col === visitedNode.col - 1)) ||\n        ((node.col === visitedNode.col) && (node.row === visitedNode.row + 1 || node.row === visitedNode.row - 1)))) {\n            if (node.distance > visitedNode.distance + 1) {\n                node.distance = visitedNode.distance + 1;\n                buildMinHeap(unvisitedNodes);\n                node.previousNode = visitedNode;\n                adjacentCount++;\n            }\n        }\n    }\n    \n    if (adjacentCount === 0) { }\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction createTestGrid() {\n    const grid = [];\n    for (let row = 0; row < 20; row++) {\n        grid[row] = [];\n        for (let col = 0; col < 50; col++) {\n            if (row === 10 && col === 15) {\n                grid[row].push({ row, col, isStart: true, isFinish: false, isWall: false, isVisited: false, distance: Infinity })\n            } else if (row === 10 && col === 35) {\n                grid[row].push({ row, col, isStart: false, isFinish: true, isWall: false, isVisited: false, distance: Infinity })\n            } else {\n                let isWall = false;\n                if (col === 28 && row !== getRandomIntFromInterval(0, 10) && row !== getRandomIntFromInterval(11, 19)) isWall = true;\n                grid[row].push({ row, col, isStart: false, isFinish: false, isWall, isVisited: false, distance: Infinity })\n            }\n            \n        }\n    }\n    return grid;\n}\n\nfunction getStartNode(grid) {\n    for (const row of grid) {\n        for (const node of row) {\n            if (node.isStart === true) return node;\n        }\n    }\n}\n\nfunction getFinishNode(grid) {\n    for (const row of grid) {\n        for (const node of row) {\n            if (node.isFinish === true) return node;\n        }\n    }\n}\n\n\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n\nfunction getRandomIntFromInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is exclusive and the minimum is inclusive\n}\n\n/*************** Heap Helper functions ***************/\n\nfunction buildMinHeap(nodes) {\n    const size = nodes.length;\n    \n    for (let i = Math.floor(size / 2) - 1; i >= 0; i--) {\n        minHeapify(nodes, size, i)\n    }\n    \n    return nodes;\n}\n\nfunction minHeapify(nodes, size, i) {\n    let smallest = i;\n    let left = i * 2 + 1;\n    let right = left + 1;\n\n    if (right < size && nodes[right].distance < nodes[smallest].distance) {\n        smallest = right\n    }\n    \n    if (left < size && nodes[left].distance < nodes[smallest].distance) {\n        smallest = left;\n    }\n    \n    if (smallest !== i) {\n        const temp = nodes[i];\n        nodes[i] = nodes[smallest];\n        nodes[smallest] = temp;\n        minHeapify(nodes, size, smallest);\n    }\n    return nodes\n    \n}\n\nfunction extractMin(nodes) {\n    const minNode = nodes[0];\n    nodes[0] = nodes.pop()\n    let size = nodes.length - 1;\n    minHeapify(nodes, size, 0);\n    \n    return minNode;\n}\n\n","import React, { useState, useEffect } from 'react';\nimport Node from '../Node/Node.js';\nimport Header from '../Header/Header.js';\nimport NodesIndex from '../NodesIndex/NodesIndex.js';\n\nimport dijkstra, { getNodesInShortestPathOrder } from '../../algorithms/dijkstra'\n\nimport './PathfindingVisualizer.css';\n\nconst WEB_SCREEN_ROWS = 25;\nconst WEB_SCREEN_COLUMNS = 60;\nconst MOBILE_SCREEN_ROWS = 21;\nconst MOBILE_SCREEN_COLUMNS = 20;\n\nconst START_NODE_ROW = 11;\nconst START_NODE_COL = 7;\nconst FINISH_NODE_ROW = 11;\nconst FINISH_NODE_COL = 53;\n\nconst MOBILE_START_NODE_ROW = 2;\nconst MOBILE_START_NODE_COL = 2;\nconst MOBILE_FINISH_NODE_ROW = 18;\nconst MOBILE_FINISH_NODE_COL = 17;\n\nexport default function PathfindingVisualizer(props) {\n    \n    const [grid, setGrid] = useState([]);\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\n    const [isRunning, setIsRunning] = useState(false);\n\n    useEffect(() => {\n        resetGrid();\n    }, []);\n\n    window.mobileCheck = function() {\n        let check = false;\n        (function(a) {\n            if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4))) check = true;\n        })(navigator.userAgent||navigator.vendor||window.opera);\n        return check;\n    };\n    \n    const resetGrid = () => {\n        const grid = getInitialGrid();\n        setGrid(grid);\n    }\n    \n    const getInitialGrid = () => {\n        const newGrid = [];\n        let rows\n        let columns\n        if (window.mobileCheck()) {\n            rows = MOBILE_SCREEN_ROWS\n            columns = MOBILE_SCREEN_COLUMNS\n        } else {\n            rows = WEB_SCREEN_ROWS\n            columns = WEB_SCREEN_COLUMNS\n        }\n        for (let row = 0; row < rows; row++) {\n            const currentRow = [];\n            for (let col = 0; col < columns; col++) {\n                currentRow.push(createNode(row, col));\n            }\n            newGrid.push(currentRow);\n        }\n        return newGrid;\n    };\n    \n    const createRandomMaze = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const newNode = createNode(row, col);\n                if (!newNode.isStart && !newNode.isFinish) {\n                    document.getElementById(`node-${row}-${col}`).className = `node`;\n                    newNode.isWall = Math.random() >= 0.7;\n                    if (newNode.isWall) {\n                        document.getElementById(`node-${row}-${col}`).className = `node node-wall`;\n                    }\n                }\n                if (newNode.isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n                \n                currentRow.push(newNode)\n            }\n            newGrid.push(currentRow)\n        }\n        setGrid(newGrid);\n    }\n\n    const createNode = (row, col) => {\n        if (window.mobileCheck()) {\n            return {\n                row,\n                col,\n                isStart: row === MOBILE_START_NODE_ROW && col === MOBILE_START_NODE_COL,\n                isFinish: row === MOBILE_FINISH_NODE_ROW && col === MOBILE_FINISH_NODE_COL,\n                distance: Infinity,\n                isVisited: false,\n                isWall: false,\n                isShortestPath: false,\n                previousNode: null,\n            }\n        } else {\n            return {\n                row,\n                col,\n                isStart: row === START_NODE_ROW && col === START_NODE_COL,\n                isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n                distance: Infinity,\n                isVisited: false,\n                isWall: false,\n                isShortestPath: false,\n                previousNode: null,\n            };\n        }\n    };\n    \n    const clearBoard = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const newNode = createNode(row, col);\n                if (!newNode.isStart && !newNode.isFinish) {\n                    document.getElementById(`node-${row}-${col}`).className =\n                        `node`;\n                }\n                if (newNode.isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n                \n                currentRow.push(newNode)\n            }\n            newGrid.push(currentRow)\n        }\n        setGrid(newGrid)\n    }\n\n    const clearPath = () => {\n        const newGrid = [];\n        for (let row = 0; row < grid.length; row++) {\n            const currentRow = [];\n            for (let col = 0; col < grid[row].length; col++) {\n                const node = grid[row][col]\n                let newNode = createNode(row, col);\n                newNode = { ...newNode, \n                    isStart: node.isStart, \n                    isFinish: node.isFinish, \n                    isWall: node.isWall, \n                }\n                if (newNode.isStart) newNode.distance = 0;\n                currentRow.push(newNode);\n                document.getElementById(`node-${row}-${col}`).classList.remove('node-visited');\n                document.getElementById(`node-${row}-${col}`).classList.remove('node-shortest-path');\n                if (newNode.isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish'; \n\n            }\n            newGrid.push(currentRow)\n        }\n        console.log(newGrid);\n        setGrid(newGrid);\n    }\n\n    const changeButtonClass = () => {\n        for (let i = 0; i < 4; i++) {\n            if (i === 0) {\n                document.getElementById('btn-0').classList.add('visualize-btn');\n                document.getElementById('btn-0').classList.remove('visualize-btn-running');\n            } else {\n                document.getElementById(`btn-${i}`).classList.add('toolbar-btn');\n                document.getElementById(`btn-${i}`).classList.remove('toolbar-btn-running');\n            }\n            document.getElementById(`btn-${i}`).disabled = false;\n        }\n    };\n\n    const toggleButton = () => {\n        setIsRunning(prevState => !prevState)\n    };\n\n    const handleMouseDown = (row, col) => { \n        const newGrid = getNewGridWithWallToggled(grid, row, col);\n        setGrid(newGrid);\n        setMouseIsPressed(true);\n    }\n\n    const handleMouseEnter = (row, col) => {\n        if (!mouseIsPressed) return;\n        const newGrid = getNewGridWithWallToggled(grid, row, col);\n        setGrid(newGrid);\n    }\n\n    const handleMouseUp = () => {\n        setMouseIsPressed(false);\n    }\n\n\n    const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length - 1) {\n                setTimeout(() => {\n                    animateShortestPath(nodesInShortestPathOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                const startNodeClass = node.isStart ? 'node-start' : '';\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    `node node-visited ${startNodeClass}`;\n            }, 10 * i);\n        }\n    };\n\n    const animateShortestPath = (nodesInShortestPathOrder) => {\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n            setTimeout(() => {\n                const node = nodesInShortestPathOrder[i];\n                node.isShortestPath = true;\n                const startNodeClass = node.isStart ? 'node-start' : '';\n                const finishNodeClass = node.isFinish ? 'node-finish' : '';\n                const arrowNodeClass = getArrowDirectionClass(node);\n                document.getElementById(`node-${node.row}-${node.col}`).className =\n                    `node node-shortest-path ${startNodeClass} ${finishNodeClass} ${arrowNodeClass}`;\n                setTimeout(() => {\n                    if (!node.isFinish) {\n                        document.getElementById(`node-${node.row}-${node.col}`).className =\n                            `node node-shortest-path ${startNodeClass} ${finishNodeClass}`;\n                    }\n                }, 2 * i);\n            }, 35 * i);\n            if (i === nodesInShortestPathOrder.length - 1) {\n                setTimeout(() => {\n                    toggleButton();\n                }, 50 * i);\n            }\n        }\n    };\n\n    const visualizeDijkstra = () => {\n        toggleButton();\n        clearPath();\n        const startNode = window.mobileCheck() ? grid[MOBILE_START_NODE_ROW][MOBILE_START_NODE_COL] : grid[START_NODE_ROW][START_NODE_COL]\n        const finishNode = window.mobileCheck() ? grid[MOBILE_FINISH_NODE_ROW][MOBILE_FINISH_NODE_COL] : grid[FINISH_NODE_ROW][FINISH_NODE_COL]\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);        \n    };\n    \n    const getNewGridWithWallToggled = (grid, row, col) => {\n        if (grid[row][col].isStart || grid[row][col].isFinish) return grid;\n        const newGrid = grid.slice();\n        const node = newGrid[row][col];\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n        };\n        newGrid[row][col] = newNode;\n        return newGrid;\n    };\n    \n    const getArrowDirectionClass = (node) => {\n        const previousNode = node.previousNode;\n        if (!previousNode) return '';\n        const row = previousNode.row;\n        const col = previousNode.col;\n    \n        const arrowClassName = (row - 1 === node.row)\n            ? 'node-arrowup'\n            : (col - 1 === node.col)\n                ? 'node-arrowleft'\n                : (row + 1 === node.row)\n                    ? 'node-arrowdown'\n                    : 'node-arrowright';\n    \n        return arrowClassName;\n    }\n\n    return (\n        <div className=\"app-body\">\n            <Header\n                visualizeDijkstra={visualizeDijkstra}\n                clearBoard={clearBoard} \n                clearPath={clearPath}\n                createRandomMaze={createRandomMaze}\n                changeButtonClass={changeButtonClass}\n                isRunning={isRunning}\n                ></Header>\n            <NodesIndex></NodesIndex>\n            <div className=\"main-message\">Create a Maze and visualize the shortest path with Dijkstra's Algorithm!</div>\n            <table className=\"grid\">\n                <tbody>\n                    {grid.map((row, rowIdx) => {\n                        return <tr className=\"grid-row\" key={rowIdx}>\n                            {row.map((node, nodeIdx) => {\n                                const { row, col, isFinish, isStart, isWall, isVisited, isShortestPath } = node;\n                                return <Node\n                                    key={nodeIdx}\n                                    row={row}\n                                    col={col}\n                                    isFinish={isFinish}\n                                    isStart={isStart}\n                                    isWall={isWall}\n                                    isVisited={isVisited}\n                                    isShortestPath={isShortestPath}\n                                    mouseIsPressed={mouseIsPressed}\n                                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                                    onMouseUp={handleMouseUp}\n                                ></Node>\n                            })}\n                        </tr>\n                    })}\n                </tbody>\n            </table>\n        </div>\n    );\n}\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './components/PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}